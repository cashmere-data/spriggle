-- -- COMPLETELY DESTROYS ALL DATA IN THE DATABASE EXCEPT FOR THE "prompts" TABLE. USE WITH CAUTION.
-- DO $$ DECLARE
--     r RECORD;
-- BEGIN
--     FOR r IN (SELECT tablename FROM pg_tables WHERE schemaname = 'public' AND tablename != 'prompts') LOOP
--         EXECUTE 'DROP TABLE IF EXISTS public.' || quote_ident(r.tablename) || ' CASCADE';
--     END LOOP;
-- END $$;






-- Custom types


/**
  * permissions
  * - create collection
  * - delete collections
  * - update collections
  * - create tags
  * - delete tags
  * - update tags
  * - tag collections
  */


-- Custom types
create type public.app_permission as enum ('app_settings.update', 'app_settings.view');
create type public.app_role as enum ('admin');

-- -- USERS
-- create table public.users (
--   id          uuid references auth.users not null primary key, -- UUID from auth.users
--   username    text
-- );
-- comment on table public.users is 'Profile data for each user.';
-- comment on column public.users.id is 'References the internal Supabase Auth user.';

-- USER ROLES
create table public.user_roles (
  id        bigint generated by default as identity primary key,
  user_id   uuid references auth.users on delete cascade not null,
  role      app_role not null,
  unique (user_id, role)
);
comment on table public.user_roles is 'Application roles for each user.';

-- ROLE PERMISSIONS
create table public.role_permissions (
  id           bigint generated by default as identity primary key,
  role         app_role not null,
  permission   app_permission not null,
  unique (role, permission)
);
comment on table public.role_permissions is 'Application permissions for each role.';

insert into public.role_permissions (role, permission)
values
  ('admin', 'app_settings.update'),
  ('admin', 'app_settings.view');

-- SECURE TABLES
alter table public.user_roles enable row level security;
alter table public.role_permissions enable row level security;

-- Create the auth hook function
create or replace function public.custom_access_token_hook(event jsonb)
returns jsonb
language plpgsql
stable
as $$
  declare
    claims jsonb;
    user_role public.app_role;
  begin
    -- Fetch the user role in the user_roles table
    select role into user_role from public.user_roles where user_id = (event->>'user_id')::uuid;

    claims := event->'claims';

    if user_role is not null then
      -- Set the claim
      claims := jsonb_set(claims, '{user_role}', to_jsonb(user_role));
    else
      claims := jsonb_set(claims, '{user_role}', 'null');
    end if;

    -- Update the 'claims' object in the original event
    event := jsonb_set(event, '{claims}', claims);

    -- Return the modified or original event
    return event;
  end;
$$;

grant usage on schema public to supabase_auth_admin;

grant execute
  on function public.custom_access_token_hook
  to supabase_auth_admin;

revoke execute
  on function public.custom_access_token_hook
  from authenticated, anon, public;

grant all
  on table public.user_roles
to supabase_auth_admin;

revoke all
  on table public.user_roles
  from authenticated, anon, public;

create policy "Allow auth admin to read user roles" ON public.user_roles
as permissive for select
to supabase_auth_admin
using (true)








-- type should be an enum that can expand. for now, the values to include are "string" and "boolean". create the enum value as well

DROP TYPE public.app_setting_type;
create type public.app_setting_type as enum ('string', 'boolean');

-- create settings table. settings table should include the following columns: field (display name of the setting), type (app_setting_type), value (can be anything, will be parsed based on the type), description (description of the field), key (key value of the setting in a form), created_at, updated_at. created at should generate automatically when the entry is added, and updated_at should update every time the field value changes 

create table public.app_settings (
  id serial primary key,
  field varchar(255) not null,
  type app_setting_type not null,
  value text not null,
  description text not null,
  key varchar(255) not null,
  order integer not null default 0,
  created_at timestamp not null default now(),
  updated_at timestamp not null default now()
);

-- default populate this table with two entries with the following keys: cashmereApiKey and openAiApiKey. The rest of the values should reflect these keys
insert into public.app_settings (field, type, value, description, key, order)
values
  ('Cashmere API Key', 'string', '', 'API Key for Cashmere', 'cashmereApiKey', 0),
  ('OpenAI API Key', 'string', '', 'API Key for OpenAI', 'openAiApiKey', 1);



-- GENERATE JOBS TABLES
-- need to generate a table to track jobs. it should include the following fields: id (int), created_at (timestamp), updated_at (timestamp), status (enum: 'pending', 'processing', 'completed', 'failed'), type: (enum: 'block', 'section', 'omnibook'), data (jsonb), log (jsonb array), 


-- only drop the job_status if the type already exists
DROP TYPE IF EXISTS public.job_status;
CREATE TYPE public.job_status as enum ('pending', 'processing', 'completed', 'failed');

DROP TYPE IF EXISTS public.job_type;
CREATE TYPE public.job_type as enum ('text', 'section', 'omnibook');

CREATE TABLE public.jobs (
  id serial primary key,
  status job_status not null,
  type job_type not null,
  data jsonb not null,
  log jsonb[] not null,
  created_at timestamp not null default now(),
  updated_at timestamp not null default now()
);

-- Create a unique index on the bookBlockId and omnibookId properties within the data JSONB column
create unique index unique_book_block_omnibook on public.jobs (
  (data->>'bookBlockId'),
  (data->>'omnibookId')
);

-- this is just a temporary solution. we'll come back to this later once everyting else is working
ALTER TABLE storage.objects DISABLE ROW LEVEL SECURITY;
ALTER TABLE storage.buckets DISABLE ROW LEVEL SECURITY;
